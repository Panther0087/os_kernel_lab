## 动态内存分配

我们之前在 C++ 语言等中使用过 `malloc` 等动态内存分配方法，与在编译期就已完成的静态内存分配相比，动态内存分配可以根据程序运行时状态修改内存申请的时机及大小，显得更为灵活，但是这是需要操作系统的支持的，同时也会带来一些开销。

我们的内核中也需要动态内存分配。典型的应用场景有：

- `Box<T>` ，你可以理解为它和 `malloc` 有着相同的功能；
- 引用计数 `Rc<T>`，原子引用计数 `Arc<T>`，主要用于在引用计数清零，即某对象不再被引用时，对该对象进行自动回收；
- 一些 std 中的数据结构，如 `Vec` 和 `HashMap` 等。

为了在我们的内核中支持动态内存分配，在 Rust 语言中，我们需要实现 `Trait GlobalAlloc`，将这个类实例化，并使用语义项 `#[global_allocator]` 进行标记。这样的话，编译器就会知道如何进行动态内存分配。

为了实现 `Trait GlobalAlloc`，我们需要支持这么两个函数：

```rust
unsafe fn alloc(&self, layout: Layout) -> *mut u8;
unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);
```

可见我们要分配/回收一块虚拟内存。

那么这里面的 `Layout` 又是什么呢？从文档中可以找到，它有两个字段：`size` 表示要分配的字节数，`align` 则表示分配的虚拟地址的最小对齐要求，即分配的地址要求是 `align` 的倍数。这里的 `align` 必须是 2 的幂次。

也就表示，我们的需求是分配一块连续的、大小至少为 `size` 字节的虚拟内存，且对齐要求为 `align` 。

### 连续内存分配算法

假设我们已经有一整块虚拟内存用来分配，那么如何进行分配呢？

我们可能会想到一些简单粗暴的方法，比如对于一个分配任务，贪心地将其分配到可行的最小地址去。这样一直分配下去的话，我们分配出去的内存都是连续的，看上去很合理的利用了内存。

但是一旦涉及到回收的话，设想我们在连续分配出去的很多块内存中间突然回收掉一块，它虽然是可用的，但是由于上下两边都已经被分配出去，它就只有这么大而不能再被拓展了，这种可用的内存我们称之为**外碎片**。

随着不断回收会产生越来越多的碎片，某个时刻我们可能会发现，需要分配一块较大的内存，几个碎片加起来大小是足够的，但是单个碎片是不够的。我们会想到通过**碎片整理**将几个碎片合并起来。但是这个过程的开销极大。

老师在课堂上介绍了若干管理分配和碎片的算法，包括伙伴系统（Buddy System）和 SLAB 分配器等算法，我们在这里使用 Buddy System 来实现这件事情。

### 支持动态内存分配

为了避免重复造轮子，我们可以调用开源的 Buddy System Allocator。

<!-- TODO 代码 -->

### 动态内存分配测试

现在我们来测试一下动态内存分配是否有效，分别动态分配一个整数和一个数组：

<!-- TODO 测试 -->

最后，运行一下会得到如下的类似输出：

<!-- TODO 输出 -->

我们可以发现这些动态分配的变量可以使用了，而且通过查看它们的地址我们发现它们都在 .bss 段里面，这是因为提供给动态内存分配器的那块内存就在该段里面。